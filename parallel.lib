////////////////////////////////////////////////////////////////////
version="$Id$";
category="General purpose";
info="
LIBRARY:   parallel.lib  Tools for parallelization
AUTHOR:    Andreas Steenpass, e-mail: steenpass@mathematik.uni-kl.de

OVERVIEW:
This library provides tools to do several computations in parallel. They
are aimed at ordinary Singular users as well as authors of Singular
libraries.
@* Even without this library, it is possible to execute self-defined
Singular commands in parallel using @ref{links}, but the handling of
such links can be quite tedious. With the pocedures described below,
this can be done by one-line commands.
@* There are many parallel 'skeletons' (i.e. ways in which parallel
tasks rely upon and interact with each other). A few of them are already
implemented. Future plans include an abstraction layer for modular
techniques (see @ref{modular_lib}), 'worker farms', and parallel tests.

SEE ALSO:  link, tasks_lib, modular_lib, modstd_lib, assprimeszerodim_lib

KEYWORDS:  parallel.lib; Parallelization; Links, user interface;
           Skeletons for parallelization; Distributed computing

PROCEDURES:
  parallelWaitN(...)     execute several jobs in parallel,
                         wait for N of them to finish
  parallelWaitFirst(...) execute several jobs in parallel,
                         wait for the first to finish
  parallelWaitAll(...)   execute several jobs in parallel,
                         wait for all of them to finish
";

LIB "tasks.lib";

proc parallelWaitN(list commands, list args, int N, list #)
"USAGE:  parallelWaitN(commands, args, N[, timeout, linktype]); commands list,
         args list, N int, timeout int, linktype string
RETURN:  a list, containing the results of commands[i] applied to arg[i],
         i = 1, ..., size(commands).
         @* The procedure waits for N jobs to finish.

         @* OPTIONAL PARAMETERS:

            An optional timeout in ms can be provided. Default is 0 which
            disables the timeout.

            Supported linktypes are up to now \"ssi\" (default) and \"mp\", see
            @ref{Ssi links} and @ref{MP links}.
NOTE:       The entries of the list commands must be strings.
         @* The entries of the list args must be lists.
         @* The type of any entry of the returned list whose corresponding task
            did not finish (due to timeout or error) is \"none\".
            Be careful when using commands whose return value might be of type
            \"none\"!
         @* The returned list may contain more than N results if several jobs
            finished \"at the same time\". It may contain less than N results
            in the case of timeout or errors occurring.
         @* MP links do not work with a 64 bit version of Singular. If you want
            to use MP links, make sure that MP is available. This can be
            checked by the Singular command @code{system(\"with\", \"MP\");}.
SEE ALSO: Ssi links, MP links, waitfirst, waitall, tasks_lib
KEYWORDS: parallelWaitN; Parallelization; Links, user interface;
          Skeletons for parallelization; Distributed computing
EXAMPLE:  @code{example parallelWaitN;} shows an example."
{
  // initialize the timer
  int oldtimerresolution = system("--ticks-per-sec");
  system("--ticks-per-sec", 1000);
  int t = rtimer;

  // auxiliary variables
  int i;

  // read optional parameters
  list defaults = list(0, "ssi");
  for(i = 1; i <= size(defaults); i++)
  {
    if(typeof(#[i]) != typeof(defaults[i]))
    {
      # = insert(#, defaults[i], i-1);
    }
  }
  if(size(#) != size(defaults))
  {
    ERROR("wrong optional parameters");
  }
  int timeout = #[1];
  string linktype = #[2];

  // error checking
  int njobs = size(commands);
  if(njobs != size(args))
  {
    ERROR("The number of commands does not match the number of lists"
         +newline+"of arguments.");
  }
  if(njobs == 0)
  {
    ERROR("no commands specified");
  }
  for(i = 1; i <= njobs; i++)
  {
    if(typeof(commands[i]) != "string")
    {
      ERROR("The first argument is not a list of strings.");
    }
    if(typeof(args[i]) != "list")
    {
      ERROR("The second argument is not a list of lists.");
    }
  }
  if(N < 0)
  {
    ERROR("The number of jobs which you want to wait for is negative.");
  }
  if(N > njobs)
  {
    ERROR("The number of jobs which you want to wait for is greater"
         +newline+"than the number of jobs itself.");
  }
  if(timeout < 0)
  {
    ERROR("The given timeout is negative.");
  }
  if(linktype != "ssi" && linktype != "mp")
  {
    ERROR("The given linktype is not recognized.");
  }

  // compute tasks
  list Links = startNTasks(commands, args);
  list links = list(Links[1]);
  int nfinished;
  int tt;
  int wait;
  int index;
  int tmp;
  list results;
  results[njobs+1] = 0;   // prevent the list from being copied again and again
  while(nfinished < N) {
    if (timeout == 0) {
        tmp = system("semaphore", "release", 0);
        wait = waitfirst(links);
        tmp = system("semaphore", "acquire", 0);
    }
    else {
        tt = timeout-(rtimer-t);
        if (tt < 0) {
            break;
        }
        else {
            tmp = system("semaphore", "release", 0);
            wait = waitfirst(links, tt);
            tmp = system("semaphore", "acquire", 0);
        }
    }
    if (wait < 1) {
        break;
    }
    index = read(links[1]);
    results[index] = read(links[1]);
    nfinished++;
  }
  if (wait == -1) {
    ERROR("All links crashed.");
  }
  while (status(links[1], "read", "ready")) {
    index = read(links[1]);
    results[index] = read(links[1]);
  }
  write(Links[2], 1);
  tmp = read(Links[2]);
  results[njobs+1] = def(0);

  // return results
  system("--ticks-per-sec", oldtimerresolution);
  return(results);
}
example
{
  "EXAMPLE:";
  echo = 2;
  LIB "primdec.lib";
  ring r = 0, (x,y,z), lp;
  ideal i = z8+z6+4z5+4z3+4z2+4, y-z2;
  ideal j = 3x3y+x3+xy3+y2z2, 2x3z-xy-xz3-y4-z2, 2x2yz-2xy2+xz2-y4;
  list commands = list("std", "primdecGTZ", "primdecSY",
                       "std", "primdecGTZ", "primdecSY");
  list args = list(list(i), list(i), list(i), list(j), list(j), list(j));
  parallelWaitN(commands, args, 3);
}

proc parallelWaitFirst(list commands, list args, list #)
"USAGE:  parallelWaitFirst(commands, args[, timeout, linktype]); commands list,
         args list, timeout int, linktype string
RETURN:  a list, containing at least one (if no timeout occurs) of the results
         of commands[i] applied to arg[i], i = 1, ..., size(commands).
         @* The command
         @code{parallelWaitFirst(list commands, list args, list #)} is
         synonymous to
         @code{parallelWaitN(list commands, list args, 1, list #)}. See
         @ref{parallelWaitN} for details on optional arguments and other
         remarks.
SEE ALSO: Ssi links, MP links, waitfirst
KEYWORDS: parallelWaitFirst; Parallelization; Links, user interface;
          Skeletons for parallelization; Distributed computing
EXAMPLE:  @code{example parallelWaitFirst;} shows an example."
{
  return(parallelWaitN(commands, args, 1, #));
}
example
{
  "EXAMPLE:";
  echo = 2;
  LIB "primdec.lib";
  ring r = 0, (x,y,z), lp;
  ideal i = z8+z6+4z5+4z3+4z2+4, y-z2;
  list commands = list("primdecGTZ", "primdecSY");
  list args = list(list(i), list(i));
  parallelWaitFirst(commands, args);
}

proc parallelWaitAll(def commands, list args, list #)
"USAGE:  parallelWaitAll(commands, args[, timeout, linktype]); commands list or
         string, args list, timeout int, linktype string
RETURN:  a list, containing the results of commands[i] applied to arg[i],
         i = 1, ..., size(commands).
         @* The command
         @code{parallelWaitAll(list commands, list args, list #)} is
         synonymous to
         @code{parallelWaitN(list commands, list args, size(args), list #)}.
         See @ref{parallelWaitN} for details on optional arguments and other
         remarks.
         If @code{commands} is of type string, this is a shortcut for a list
         of size @code{size(args)} whose entries are just this string.
SEE ALSO: Ssi links, MP links, waitall
KEYWORDS: parallelWaitAll; Parallelization; Links, user interface;
          Skeletons for parallelization; Distributed computing
EXAMPLE:  @code{example parallelWaitAll;} shows an example."
{
  if(typeof(commands) != "list" && typeof(commands) != "string")
  {
    ERROR("invalid type of first argument");
  }
  if(typeof(commands) == "list")
  {
    return(parallelWaitN(commands, args, size(args), #));
  }
  else
  {
    list cmds;
    for(int i = size(args); i > 0; i--)
    {
      cmds[i] = commands;
    }
    return(parallelWaitN(cmds, args, size(args), #));
  }
}
example
{
  "EXAMPLE:";
  echo = 2;
  ring r = 0, (x,y,z), dp;
  ideal i1 = z8+z6+4z5+4z3+4z2+4, -z2+y;
  ideal i2 = x9y2+x10, -x2y7+y8;
  ideal i3 = x3-2xy, x2y-2y2+x;
  string command = "std";
  list args = list(list(i1), list(i2), list(i3));
  parallelWaitAll(command, args);
}

proc parallelTestAND(def commands, list args, list #)
"USAGE:   parallelTestAND(commands, args[, timeout, linktype]);
          commands list or string, args list, timeout int, linktype string
RETURN:   
NOTE:     
SEE ALSO: Ssi links, MP links, waitfirst
KEYWORDS: parallelWaitFirst; Parallelization; Links, user interface;
          Skeletons for parallelization; Distributed computing
EXAMPLE:  @code{example parallelTestAND;} shows an example."
{
  list results = parallelWaitAll(commands, args, #);
  int i;
  for(i = size(results); i > 0; i--)
  {
    if(!results[i])
    {
      return(0);
    }
  }
  return(1);
}
example
{
  "EXAMPLE:";
  echo = 2;
}

proc parallelTestOR(def commands, list args, list #)
"USAGE:   parallelTestOR(commands, args[, timeout, linktype]);
          commands list or string, args list, timeout int, linktype string
RETURN:   
NOTE:     
SEE ALSO: Ssi links, MP links, waitfirst
KEYWORDS: parallelWaitFirst; Parallelization; Links, user interface;
          Skeletons for parallelization; Distributed computing
EXAMPLE:  @code{example parallelTestAND;} shows an example."
{
  list results = parallelWaitAll(commands, args, #);
  int i;
  for(i = size(results); i > 0; i--)
  {
    if(results[i])
    {
      return(1);
    }
  }
  return(0);
}
example
{
  "EXAMPLE:";
  echo = 2;
}

// TODO
/* worker farm */
static proc Create() {}


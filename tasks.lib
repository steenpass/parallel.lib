////////////////////////////////////////////////////////////////////
version="$Id$";
category="General purpose";
info="
LIBRARY:   tasks.lib  An interface for tasks using semaphores
AUTHOR:    Andreas Steenpass, e-mail: steenpass@mathematik.uni-kl.de

SEE ALSO:  link, parallel_lib, resources_lib

KEYWORDS:  Semaphores; Parallelization; Links, user interface

PROCEDURES:
  startTask(string, list)   start a new task
  stopTask(link)            stop the task
  waitTask(link)            wait for the task and pick up the result
  pollTask(link)            pick up the result, if task is ready;
                            return immediately, otherwise
";

LIB "resources.lib";

static proc mod_init()
{
    if (!defined(Resources)) {
        LIB "resources.lib";
    }
    int sem_cores = Resources::sem_cores;
    exportto(Tasks, sem_cores);
    int sem_leaves = semaphore(system("cpu")+10);
    exportto(Tasks, sem_leaves);
    int sem_queue = semaphore(2);
    exportto(Tasks, sem_queue);
    newstruct("task", "int index");
    newstruct("internal_task", "int id, string command, list arguments,"
        +"def result, string state, list links, int linkID");
    system("install", "task", "=", createTask, 1);
    system("install", "task", "==", compareTasks, 2);
    system("install", "task", "print", printTask, 1);
    list tasks;
    exportto(Tasks, tasks);
    int ntasks;
    exportto(Tasks, ntasks);
    int nlinkIDs;
    exportto(Tasks, nlinkIDs);
}

proc createTask(alias string command, alias list arguments)
{
    internal_task T;
    ntasks++;
    tasks[ntasks] = T;
    tasks[ntasks].command = command;
    tasks[ntasks].arguments = arguments;
    tasks[ntasks].state = "created";
    task t;
    t.index = ntasks;
    return(t);
}
example
{
    "EXAMPLE:";
    echo = 2;
    ring R = 0, (x,y), dp;
    ideal I = x9y2+x10, x2y7-y8;
    task t = createTask("std", list(I));
    // This is the same as:
    // task t = "std", list(I);
    t;
    killTask(t);
}

proc killTask(task t)
{
    if (t.index == 0) {
        return();
    }
    if (typeof(tasks[t.index]) != "internal_task") {
        return();
    }
    if (tasks[t.index].state == "started") {
        stopTask(t);
    }
    tasks[t.index] = def(0);
}
example
{
    "EXAMPLE:";
    echo = 2;
    ring R = 0, (x,y), dp;
    ideal I = x9y2+x10, x2y7-y8;
    task t = "std", list(I);
    startTasks(t);
    t;
    killTask(t);
    t;
    getState(t);
}

proc copyTask(task t)
{
    task t_copy;
    if (t.index == 0) {
        return(t_copy);
    }
    if (typeof(tasks[t.index]) != "internal_task") {
        return(t_copy);
    }
    if (tasks[t.index].state == "started") {
        ERROR("cannot copy a task whose state is 'started'");
    }
    ntasks++;
    tasks[ntasks] = tasks[t.index];
    t_copy.index = ntasks;
    return(t_copy);
}
example
{
    "EXAMPLE:";
    echo = 2;
    ring R = 0, (x,y), dp;
    ideal I = x9y2+x10, x2y7-y8;
    task t1 = "std", list(I);
    startTasks(t1);
    waitAllTasks(t1);
    task t2 = copyTask(t1);
    killTask(t1);
    t2;   // t2 survived
    getResult(t2);
    killTask(t2);
}

// arguments and result are not compared
proc compareTasks(task t1, task t2)
{
    if (tasks[t1.index].id != tasks[t2.index].id) {
        return(0);
    }
    if (tasks[t1.index].command != tasks[t2.index].command) {
        return(0);
    }
    if (tasks[t1.index].state != tasks[t2.index].state) {
        return(0);
    }
    if (tasks[t1.index].linkID != tasks[t2.index].linkID) {
        return(0);
    }
    return(1);
}
example
{
    "EXAMPLE:";
    echo = 2;
    ring R = 0, (x,y), dp;
    ideal I = x9y2+x10, x2y7-y8;
    task t1 = "std", list(I);
    task t2 = "std", list(I);
    compareTasks(t1, t2);
    startTasks(t1);
    waitAllTasks(t1);
    t1 == t2;   // the same as compareTasks(t1, t2);
    killTask(t1);
    killTask(t2);
    // The arguments and the result are not compared!
    ideal J = x;
    task t3 = "std", list(I);
    task t4 = "std", list(J);
    t3 == t4;
    killTask(t3);
    killTask(t4);
}

proc printTask(task t)
{
    if (t.index == 0) {
        "An undefined task";
        return();
    }
    if (typeof(tasks[t.index]) != "internal_task") {
        "An undefined task";
        return();
    }
    "A task with the following properties:"+newline
        +"command:          "+tasks[t.index].command+newline
        +"no. of arguments: "+string(size(tasks[t.index].arguments))+newline
        +"state:            "+tasks[t.index].state;
}
example
{
    "EXAMPLE:";
    echo = 2;
    ring R = 0, (x,y), dp;
    ideal I = x9y2+x10, x2y7-y8;
    task t;
    printTask(t);
    t = "std", list(I);
    t;   // the same as printTask(t);
    startTasks(t);
    waitAllTasks(t);
    t;
    killTask(t);
}

proc startTasks(list #)
"USAGE:   startTasks(commands, Arguments); commands list, Arguments list
RETURN:   a list L of two links. L[2] gives access to a supervisor link
          (*not* in the sense of scheduling) which usually remains
          unused, but shouldn't be closed or killed before enough
          results are obtained. The results can be read off from L[1].
          One result is read by applying the command read(L[1]) twice: The
          first call gives the index (of the command and its arguments
          within the input lists), the second call gives the actual
          result. The next call of read(L[1]) then gives the next index
          and so on.
SEE ALSO: startTask, stopTask, waitTask, pollTask, parallel_lib, Ssi links,
          MP links
KEYWORDS: Parallelization; Links
EXAMPLE:  example startTasks; shows an example"
{
    int nargs = size(#);
    if (nargs == 0) {
        ERROR("missing argument");
    }
    int i;
    for (i = nargs; i > 0; i--) {
        if (typeof(#[i]) != "task") {
            ERROR("argument not of type 'task' (argument no. "+string(i)+")");
        }
        if (#[i].index == 0) {
            ERROR("cannot start an undefined task (task no. "+string(i)+")");
        }
        if (typeof(tasks[#[i].index]) != "internal_task") {
            ERROR("cannot start an undefined task (task no. "+string(i)+")");
        }
        if (tasks[#[i].index].state != "created"
            && tasks[#[i].index].state != "stopped") {
            ERROR("cannot start a task whose state is not"+newline
                +"'created' or 'stopped'");
        }
    }
    for (i = nargs; i > 0; i--) {
        tasks[#[i].index].id = i;
        tasks[#[i].index].state = "started";
    }
    int pid = system("pid");
    link l(pid) = "ssi:fork";
    open(l(pid));
    write(l(pid), quote(startTasks_child(#, eval(pid))));
    int port = read(l(pid));
    link L(pid) = "ssi:connect localhost:"+string(port);
    open(L(pid));
    nlinkIDs++;
    for (i = nargs; i > 0; i--) {
        tasks[#[i].index].links = list(L(pid), l(pid));
        tasks[#[i].index].linkID = nlinkIDs;
    }
}
example
{
    "EXAMPLE:";
    echo = 2;
    ring R = 0, (x,y), dp;
    ideal I = x9y2+x10, x2y7-y8;
    task t1 = "std", list(I);
    task t2 = "slimgb", list(I);
    startTasks(t1, t2);
    waitAllTasks(t1, t2);
    getResult(t1);
    getResult(t2);
    killTask(t1);
    killTask(t2);
}

/* This procedure is started within the child after forking. */
static proc startTasks_child(list localtasks, int pid_parent)
{
    int port = system("reserve", 1);
    write(l(pid_parent), port);
    link L(pid_parent) = system("reservedLink");
    export(L(pid_parent));

    int sem_write = semaphore(1);
    int pid = system("pid");

    int nlocaltasks = size(localtasks);
    intvec state = 0:nlocaltasks;
    int nwaiting = nlocaltasks;
    int nfinished;
    intvec queue = 0, 1..nlocaltasks, 0;   // zeroes for easier handling

    list links;
    links[nlocaltasks+1] = l(pid_parent);
    intvec assignment = 0:nlocaltasks;
    int nlinks;

    int code;
    int id;
    intvec demanded_tasks = 0, 0;   // zeroes for easier handling
    int ndemanded = -1;

    int granted_leaves;
    int results_sent;

    int wait;
    int deadlock;
    int tmp;
    int i;

    while (nwaiting > 0) {
        wait = 0;
        if (nlinks == 0) {
            wait = -1;
            granted_leaves++;
            while (-wait < nwaiting) {
                if (system("semaphore", "try_acquire", sem_leaves) == 1) {
                    wait--;
                }
                else {
                    break;
                }
            }
        }
        while (wait == 0) {
            wait = waitfirst(links, 500);
            if (wait == 0) {
                while (-wait < nwaiting) {
                    if (system("semaphore", "try_acquire", sem_leaves) == 1) {
                        wait--;
                    }
                    else {
                        break;
                    }
                }
            }
        }
        if (wait < 0) {   // open (-wait) new links
            while (wait < 0) {
                wait++;
                nlinks++;
                link ll(pid)(nlinks) = "ssi:fork";
                open(ll(pid)(nlinks));
                links[nlinks] = ll(pid)(nlinks);
                write(links[nlinks],
                    quote(startTasks_grandchild(
                    eval(localtasks[queue[2]].index), eval(pid_parent),
                    eval(pid), eval(nlinks), eval(sem_write))));
                assignment[queue[2]] = nlinks;
                state[queue[2]] = 1;
                nwaiting--;
                queue = 0, queue[3..size(queue)];
            }
            // wait == 0
        }
        if (wait > 0 && wait <= nlocaltasks) {
            code = read(links[wait]);
            if (code == 1) {   // result computed
                id = read(links[wait]);
                state[id] = 2;
                if (ndemanded > 0 && isElement(demanded_tasks, id)) {
                    write(links[wait], 1);
                    demanded_tasks = removeFromIntvec(demanded_tasks, id);
                    ndemanded--;
                    results_sent++;
                }
            }
            // code == 2: startTasks_grandchild() ended, do nothing
        }
        if (wait == nlocaltasks+1) {
            code = read(l(pid_parent));
            if (code == 0) {   // stop
                id = read(l(pid_parent));
                if (state[id] == 0) {   // waiting
                    queue = removeFromIntvec(queue, id);
                }
                if (state[id] == 1 || state[id] == 2) {  // started or computed
                    close(links[assignment[id]]);
                    open(links[assignment[id]]);
                    write(links[assignment[id]],
                        quote(startTasks_grandchild(
                        eval(localtasks[queue[2]].index), eval(pid_parent),
                        eval(pid), eval(assignment[id]), eval(sem_write))));
                    assignment[queue[2]] = assignment[id];
                    assignment[id] = 0;
                    state[queue[2]] = 1;
                    queue = 0, queue[3..size(queue)];
                }
                // state[id] == -1 (stopped) or state[id] == 3 (sent)
                // should not happen
                nwaiting--;
                nfinished++;
                state[id] = -1;
            }
            if (code == 1) {   // wait
                demanded_tasks = read(l(pid_parent));
                ndemanded = read(l(pid_parent));
                if (ndemanded > size(demanded_tasks)-2) {
                    ndemanded = size(demanded_tasks)-2;
                }
                if (demanded_tasks == 0:2 && ndemanded == -1) {
                    write(l(pid_parent), results_sent);
                }
                else {
                    results_sent = 0;
                }
                deadlock = 0;
                for (i = size(demanded_tasks)-1; i > 1; i--) {
                    id = demanded_tasks[i];
                    if (state[id] == 0) {   // waiting
                        queue = give_priority(queue, id);
                        deadlock = 1;
                    }
                    if (state[id] == 2) {   // computed
                        write(links[assignment[id]], 1);
                        demanded_tasks = removeFromIntvec(demanded_tasks, id);
                        ndemanded--;
                        results_sent++;
                    }
                }
                for (i = size(demanded_tasks)-1; i > 1; i--) {
                    id = demanded_tasks[i];
                    if (state[id] == 1) {   // started
                        deadlock = 0;
                    }
                }
                if (deadlock) {
                    granted_leaves++;
                    nlinks++;
                    link ll(pid)(nlinks) = "ssi:fork";
                    open(ll(pid)(nlinks));
                    links[nlinks] = ll(pid)(nlinks);
                    write(links[nlinks],
                        quote(startTasks_grandchild(
                        eval(localtasks[queue[2]].index), eval(pid_parent),
                        eval(pid), eval(nlinks), eval(sem_write))));
                    assignment[queue[2]] = nlinks;
                    state[queue[2]] = 1;
                    nwaiting--;
                    queue = 0, queue[3..size(queue)];
                }
            }
            if (code == 2) {   // poll
                id = read(l(pid_parent));
                if (state[id] == 0) {
                    queue = give_priority(queue, id);
                }
                if (state[id] == 2) {   // computed
                    write(links[assignment[id]], 1);
                }
                write(l(pid_parent), state[id]);
            }
            if (code == 3) {   // got result
                id = read(l(pid_parent));
                write(links[assignment[id]],
                    quote(startTasks_grandchild(
                    eval(localtasks[queue[2]].index), eval(pid_parent),
                    eval(pid), eval(assignment[id]), eval(sem_write))));
                assignment[queue[2]] = assignment[id];
                assignment[id] = 0;
                state[queue[2]] = 1;
                state[id] = 3;
                nwaiting--;
                nfinished++;
                queue = 0, queue[3..size(queue)];
            }
        }
    }
    while (nfinished < nlocaltasks || ndemanded != -1) {
        wait = waitfirst(links);
        if (wait <= nlocaltasks) {
            code = read(links[wait]);
            if (code == 1) {   // result computed
                id = read(links[wait]);
                state[id] = 2;
                if (ndemanded > 0 && isElement(demanded_tasks, id)) {
                    write(links[wait], 1);
                    demanded_tasks = removeFromIntvec(demanded_tasks, id);
                    ndemanded--;
                    results_sent++;
                }
            }
            // code == 2: startTasks_grandchild() ended, do nothing
        }
        if (wait == nlocaltasks+1) {
            code = read(l(pid_parent));
            if (code == 0) {   // stop
                id = read(l(pid_parent));
                if (state[id] == 1 || state[id] == 2) {  // started or computed
                    close(links[assignment[id]]);
                    if (nlinks > granted_leaves) {
                        tmp = system("semaphore", "release", sem_leaves);
                    }
                    links[assignment[id]] = def(0);
                    nlinks--;
                    assignment[id] = 0;
                    nfinished++;
                }
                // else: nothing to do
                state[id] = -1;
            }
            if (code == 1) {   // wait
                demanded_tasks = read(l(pid_parent));
                ndemanded = read(l(pid_parent));
                if (ndemanded > size(demanded_tasks)-2) {
                    ndemanded = size(demanded_tasks)-2;
                }
                if (demanded_tasks == 0:2 && ndemanded == -1) {
                    write(l(pid_parent), results_sent);
                }
                else {
                    results_sent = 0;
                }
                for (i = size(demanded_tasks)-1; i > 1; i--) {
                    id = demanded_tasks[i];
                    if (state[id] == 2) {   // computed
                        write(links[assignment[id]], 1);
                        demanded_tasks = removeFromIntvec(demanded_tasks, id);
                        ndemanded--;
                        results_sent++;
                    }
                }
            }
            if (code == 2) {   // poll
                id = read(l(pid_parent));
                if (state[id] == 2) {   // computed
                    write(links[assignment[id]], 1);
                }
                write(l(pid_parent), state[id]);
            }
            if (code == 3) {   // got result
                id = read(l(pid_parent));
                close(links[assignment[id]]);
                if (nlinks > granted_leaves) {
                    tmp = system("semaphore", "release", sem_leaves);
                }
                links[assignment[id]] = def(0);
                nlinks--;
                assignment[id] = 0;
                state[id] = 3;
                nfinished++;
            }
        }
    }
}

/* This procedure has to be started within the grandchildren after forking. */
static proc startTasks_grandchild(int index, int pid_grandparent,
    int pid_parent, int link_no, int sem_write)
{
    def result;
    int tmp = system("semaphore", "acquire", sem_queue);
    tmp = system("semaphore", "acquire", sem_cores);
    tmp = system("semaphore", "release", sem_queue);
    execute("result = "+tasks[index].command+"("
        +argsToString("tasks[index].arguments", size(tasks[index].arguments))
        +");");
    tmp = system("semaphore", "release", sem_cores);
    write(ll(pid_parent)(link_no), 1);
    write(ll(pid_parent)(link_no), tasks[index].id);
    tmp = read(ll(pid_parent)(link_no));
    tmp = system("semaphore", "acquire", sem_write);
    write(L(pid_grandparent), index);
    write(L(pid_grandparent), result);
    tmp = system("semaphore", "release", sem_write);
    return(2);
}

static proc isElement(alias intvec v, alias int n)
{
    int i;
    for (i = size(v)-1; i > 1; i--) {
        if (v[i] == n) {
            return(1);
        }
    }
    return(0);
}

static proc removeFromIntvec(intvec v, int n)
{
    int size_v = size(v);
    int i;
    for (i = size_v-1; i > 1; i--) {
        if (v[i] == n) {
            return(v[1..(i-1)], v[(i+1)..size_v]);
        }
    }
    return(v);
}

static proc give_priority(intvec queue, int id)
{
    int size_queue = size(queue);
    int i;
    for (i = size_queue-1; i > 2; i--) {
        if (queue[i] == id) {
            return(0, id, queue[2..(i-1)], queue[(i+1)..size_queue]);
        }
    }
    return(queue);
}

proc stopTask(task t)
"USAGE:   stopTask(l); l link
RETURN:   none. Stops the task as soon as possible.
SEE ALSO: startTask, waitTask, pollTask, parallel_lib
KEYWORDS: Parallelization; Links
EXAMPLE:  example stopTask; shows an example"
{
    if (t.index == 0) {
        ERROR("cannot stop an undefined task");
    }
    if (typeof(tasks[t.index]) != "internal_task") {
        ERROR("cannot stop an undefined task");
    }
    if (tasks[t.index].state != "started") {
        ERROR("cannot stop a task whose state is not 'started'");
    }
    write(tasks[t.index].links[2], 0);
    write(tasks[t.index].links[2], tasks[t.index].id);
    tasks[t.index].id = 0;
    tasks[t.index].links = list();
    tasks[t.index].linkID = 0;
    tasks[t.index].state = "stopped";
}
example
{
    "EXAMPLE:";
    echo = 2;
    ring R = 0, (x,y), dp;
    ideal I = x9y2+x10, x2y7-y8;
    task t = "std", list(I);
    startTasks(t);
    stopTask(t);
    t;
    killTask(t);
}

proc waitTasks(list t, int N, list #)
"USAGE:   waitTask(l); l link
RETURN:   the result of the task. This command is eventually blocking.
SEE ALSO: startTask, stopTask, pollTask, parallel_lib
KEYWORDS: Parallelization; Links
EXAMPLE:  example waitTask; shows an example"
{
    /* initialize the timer */
    int oldtimerresolution = system("--ticks-per-sec");
    system("--ticks-per-sec", 1000);
    int starting_time = rtimer;

    /* read optional parameters */
    int timeout;
    if (size(#) > 0) {
        if (size(#) > 1 || typeof(#[1]) != "int") {
            ERROR("wrong optional parameter");
        }
        timeout = #[1];
    }

    /* check for errors */
    if (timeout < 0) {
        ERROR("negative timeout");
    }
    int nargs = size(t);
    if (nargs == 0) {
        ERROR("missing task");
    }
    if (N < 1 || N > nargs) {
        ERROR("wrong number of tasks to wait for");
    }
    int i;
    for (i = nargs; i > 0; i--) {
        if (typeof(t[i]) != "task") {
            ERROR("element not of type 'task' (element no. "+string(i)+")");
        }
        if (t[i].index == 0) {
            ERROR("cannot wait for an undefined task (task no. "+string(i)
                +")");
        }
        if (typeof(tasks[t[i].index]) != "internal_task") {
            ERROR("cannot wait for an undefined task (task no. "+string(i)
                +")");
        }
        if (tasks[t[i].index].state != "started"
            && tasks[t[i].index].state != "completed") {
            ERROR("cannot wait for a task whose state is not"+newline
                +"'started' or 'completed' (task no. "+string(i)+")");
        }
    }

    /* sort the tasks */
    int ncompleted;
    list requests;
    list links;
    int sorted_in;
    int j;
    for (i = 1; i <= nargs; i++) {
        if (tasks[t[i].index].state == "completed") {
            ncompleted++;
        }
        else {   // tasks[t[i].index].state == "started"
            sorted_in = 0;
            for (j = size(requests); j > 0; j--) {
                if (requests[j][1] == tasks[t[i].index].linkID) {
                    requests[j][2][size(requests[j][2])+1] =
                        tasks[t[i].index].id;
                    sorted_in = 1;
                    break;
                }
            }
            if (!sorted_in) {
                requests[size(requests)+1] = list(tasks[t[i].index].linkID,
                    intvec(0, tasks[t[i].index].id),
                    tasks[t[i].index].links[2]);
                links[size(links)+1] = tasks[t[i].index].links[1];
            }
        }
    }

    /* send the reqests */
    for (j = size(requests); j > 0; j--) {
        requests[j][2][size(requests[j][2])+1] = 0;
        write(requests[j][3], 1);
        write(requests[j][3], requests[j][2]);
        write(requests[j][3], N);
    }

    /* wait for the results */
    int wait;
    int index;
    int results_got;
    int remaining_time;
    int tmp;
    while (ncompleted < N) {
        wait = waitfirst(links, 0);
        if (wait == 0) {
            if (timeout == 0) {
                tmp = system("semaphore", "release", sem_cores);
                wait = waitfirst(links);
                tmp = system("semaphore", "acquire", sem_cores);
            }
            else {
                remaining_time = timeout-(rtimer-starting_time);
                if (remaining_time < 0) {
                    break;
                }
                else {
                    tmp = system("semaphore", "release", sem_cores);
                    wait = waitfirst(links, remaining_time);
                    tmp = system("semaphore", "acquire", sem_cores);
                }
            }
        }
        if (wait < 1) {
            break;
        }
        index = read(links[wait]);
        tasks[index].result = read(links[wait]);
        write(tasks[index].links[2], 3);
        write(tasks[index].links[2], tasks[index].id);
        tasks[index].id = 0;
        tasks[index].links = list();
        tasks[index].linkID = 0;
        tasks[index].state = "completed";
        ncompleted++;
        results_got++;
    }
    if (wait == -1) {
        ERROR("error in waitfirst()");
    }

    /* end communication process */
    for (j = size(requests); j > 0; j--) {
        write(requests[j][3], 1);
        write(requests[j][3], 0:2);
        write(requests[j][3], -1);
    }
    int results_sent;
    for (j = size(requests); j > 0; j--) {
        results_sent = results_sent + read(requests[j][3]);
    }
    while (results_sent > results_got) {
        wait = waitfirst(links);
        if (wait == -1) {
            ERROR("error in waitfirst()");
        }
        index = read(links[wait]);
        tasks[index].result = read(links[wait]);
        write(tasks[index].links[2], 3);
        write(tasks[index].links[2], tasks[index].id);
        tasks[index].id = 0;
        tasks[index].links = list();
        tasks[index].linkID = 0;
        tasks[index].state = "completed";
        results_got++;
    }

    /* list completed tasks */
    list completed;
    completed[nargs+1] = 0;
    j = 0;
    for (i = 1; i <= nargs; i++) {
        if (tasks[t[i].index].state == "completed") {
            j++;
            completed[j] = i;
        }
    }
    completed[nargs+1] = def(0);

    /* return the result */
    system("--ticks-per-sec", oldtimerresolution);
    return(completed);
}
example
{
    "EXAMPLE:";
    echo = 2;
    ring R = 0, (x,y), dp;
    ideal I = x9y2+x10, x2y7-y8;
    task t1 = "std", list(I);
    task t2 = "slimgb", list(I);
    startTasks(t1, t2);
    waitTasks(list(t1, t2), 2);   // wait for both tasks
    getResult(t1);
    getResult(t2);
    killTask(t1);
    killTask(t2);
}

proc waitAllTasks(list #)
{
    list tmp = waitTasks(#, size(#));
}
example
{
    "EXAMPLE:";
    echo = 2;
    ring R = 0, (x,y), dp;
    ideal I = x9y2+x10, x2y7-y8;
    task t1 = "std", list(I);
    task t2 = "slimgb", list(I);
    startTasks(t1, t2);
    waitAllTasks(t1, t2);   // the same as 'waitTasks(list(t1, t2), 2);',
                            // but without return value
    getResult(t1);
    getResult(t2);
    killTask(t1);
    killTask(t2);
}

proc pollTask(task t)
"USAGE:   pollTask(l); l link
RETURN:   a list result. result[1] is 1 if the task is finished and 0
          otherwise. If the task is finished, then result[2] is the
          result of the task.
SEE ALSO: startTask, stopTask, waitTask, parallel_lib
KEYWORDS: Parallelization; Links
EXAMPLE:  example pollTask; shows an example"
{
    if (t.index == 0) {
        ERROR("cannot poll an undefined task");
    }
    if (typeof(tasks[t.index]) != "internal_task") {
        ERROR("cannot poll an undefined task");
    }
    if (tasks[t.index].state != "started"
        && tasks[t.index].state != "completed") {
        ERROR("cannot poll a task whose state is not"+newline
            +"'started' or 'completed'");
    }
    if (tasks[t.index].state == "completed") {
        return(1);
    }
    // tasks[t.index].state == "started"
    write(tasks[t.index].links[2], 2);
    write(tasks[t.index].links[2], tasks[t.index].id);
    int state = read(tasks[t.index].links[2]);
    if (state == 0 || state == 1) {   // waiting or started
        return(0);
    }
    if (state == 2) {   // computed
        int index = read(tasks[t.index].links[1]);   // index == t.index
        tasks[t.index].result = read(tasks[t.index].links[1]);
        write(tasks[t.index].links[2], 3);
        write(tasks[t.index].links[2], tasks[t.index].id);
        tasks[t.index].id = 0;
        tasks[t.index].links = list();
        tasks[t.index].linkID = 0;
        tasks[t.index].state = "completed";
        return(1);
    }
    // state == -1 (stopped) or state == 3 (sent) should not happen
}
example
{
    "EXAMPLE:";
    echo = 2;
    ring R = 0, (x,y), dp;
    ideal I = x9y2+x10, x2y7-y8;
    task t = "std", list(I);
    startTasks(t);
    waitAllTasks(t);
    pollTask(t);   // task already completed
    t;
    getResult(t);
    killTask(t);
}

proc getCommand(task t)
{
    if (t.index == 0) {
        ERROR("cannot get command of an undefined task");
    }
    if (typeof(tasks[t.index]) != "internal_task") {
        ERROR("cannot get command of an undefined task");
    }
    return(tasks[t.index].command);
}
example
{
    "EXAMPLE:";
    echo = 2;
    ring R = 0, (x,y), dp;
    ideal I = x9y2+x10, x2y7-y8;
    task t = "std", list(I);
    getCommand(t);
    killTask(t);
}

proc getArguments(task t)
{
    if (t.index == 0) {
        ERROR("cannot get arguments of an undefined task");
    }
    if (typeof(tasks[t.index]) != "internal_task") {
        ERROR("cannot get arguments of an undefined task");
    }
    return(tasks[t.index].arguments);
}
example
{
    "EXAMPLE:";
    echo = 2;
    ring R = 0, (x,y), dp;
    ideal I = x9y2+x10, x2y7-y8;
    task t = "std", list(I);
    getArguments(t);
    killTask(t);
}

proc getResult(task t)
{
    if (t.index == 0) {
        ERROR("cannot get result of an undefined task");
    }
    if (typeof(tasks[t.index]) != "internal_task") {
        ERROR("cannot get result of an undefined task");
    }
    if (tasks[t.index].state != "completed") {
        ERROR("cannot get result of a task which is not completed");
    }
    return(tasks[t.index].result);
}
example
{
    "EXAMPLE:";
    echo = 2;
    ring R = 0, (x,y), dp;
    ideal I = x9y2+x10, x2y7-y8;
    task t = "std", list(I);
    startTasks(t);
    waitAllTasks(t);
    getResult(t);
    killTask(t);
}

proc getState(task t)
{
    if (t.index == 0) {
        return("undefined");
    }
    if (typeof(tasks[t.index]) != "internal_task") {
        return("undefined");
    }
    return(tasks[t.index].state);
}
example
{
    "EXAMPLE:";
    echo = 2;
    ring R = 0, (x,y), dp;
    ideal I = x9y2+x10, x2y7-y8;
    task t = "std", list(I);
    getState(t);
    startTasks(t);
    getState(t);
    waitAllTasks(t);
    getState(t);
    killTask(t);
    getState(t);
}

proc semaphore(int n)
{
    int i = 1;
    while (system("semaphore", "exists", i) == 1) {
        i++;
    }
    if (system("semaphore", "init", i, n) != 1) {
        ERROR("no more semphores");
    }
    return(i);
}
example
{
    "EXAMPLE:";
    echo = 2;
    int sem = semaphore(1);
    system("semaphore", "acquire", sem);
    system("semaphore", "try_acquire", sem);
    system("semaphore", "release", sem);
    system("semaphore", "try_acquire", sem);
}

/ * construct the string "name[1], name[2], name[3], ..., name[length]" */
static proc argsToString(string name, int length)
{
    string output;
    if (length > 0) {
        output = name+"[1]";
    }
    int i;
    for (i = 2; i <= length; i++) {
        output = output+", "+name+"["+string(i)+"]";
    }
    return(output);
}

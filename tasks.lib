////////////////////////////////////////////////////////////////////
version="$Id$";
category="General purpose";
info="
LIBRARY:   tasks.lib  An interface for tasks using semaphores
AUTHOR:    Andreas Steenpass, e-mail: steenpass@mathematik.uni-kl.de

SEE ALSO:  link, parallel_lib, resources_lib

KEYWORDS:  Semaphores; Parallelization; Links, user interface

PROCEDURES:
  startTask(string, list)   start a new task
  stopTask(link)            stop the task
  waitTask(link)            wait for the task and pick up the result
  pollTask(link)            pick up the result, if task is ready;
                            return immediately, otherwise
";

LIB "resources.lib";

static proc mod_init()
{
    if (!defined(Resources)) {
        LIB "resources.lib";
    }
    int sem_cores = Resources::sem_cores;
    exportto(Tasks, sem_cores);
    int sem_leaves = semaphore(system("cpu")+10);
    exportto(Tasks, sem_leaves);
    int sem_queue = semaphore(2);
    exportto(Tasks, sem_queue);
    newstruct("task", "int index");
    newstruct("internal_task", "int id, string command, list arguments,"
        +"def result, string state, list links");
    system("install", "task", "=", createTask, 1);
    system("install", "task", "print", printTask, 1);
    list tasks;
    exportto(Tasks, tasks);
    int ntasks;
    exportto(Tasks, ntasks);
}

proc createTask(alias string command, alias list arguments)
{
    internal_task T;
    ntasks++;
    tasks[ntasks] = T;
    tasks[ntasks].command = command;
    tasks[ntasks].arguments = arguments;
    tasks[ntasks].state = "created";
    task t;
    t.index = ntasks;
    return(t);
}

proc killTask(task t)
{
    if (t.index == 0) {
        return();
    }
    if (typeof(tasks[t.index]) != "internal_task") {
        return();
    }
    if (tasks[t.index].state == "started") {
        stopTask(t);
    }
    tasks[t.index] = def(0);
}

proc printTask(task t)
{
    string out;
    if (t.index == 0) {
        out = "An undefined task"+newline;
        return(out);
    }
    if (typeof(tasks[t.index]) != "internal_task") {
        out = "An undefined task"+newline;
        return(out);
    }
    out = "A task with the following properties:"+newline
        +"command:          "+tasks[t.index].command+newline
        +"no. of arguments: "+string(size(tasks[t.index].arguments))+newline
        +"state:            "+tasks[t.index].state+newline;
    return(out);
}

proc startTasks(list #)
"USAGE:   startTasks(commands, Arguments); commands list, Arguments list
RETURN:   a list L of two links. L[2] gives access to a supervisor link
          (*not* in the sense of scheduling) which usually remains
          unused, but shouldn't be closed or killed before enough
          results are obtained. The results can be read off from L[1].
          One result is read by applying the command read(L[1]) twice: The
          first call gives the index (of the command and its arguments
          within the input lists), the second call gives the actual
          result. The next call of read(L[1]) then gives the next index
          and so on.
SEE ALSO: startTask, stopTask, waitTask, pollTask, parallel_lib, Ssi links,
          MP links
KEYWORDS: Parallelization; Links
EXAMPLE:  example startTasks; shows an example"
{
    int nargs = size(#);
    if (nargs == 0) {
        ERROR("missing argument");
    }
    int i;
    for (i = nargs; i > 0; i--) {
        if (typeof(#[i]) != "task") {
            ERROR("argument not of type 'task' (argument no. "+string(i)+")");
        }
        if (#[i].index == 0) {
            ERROR("cannot start an undefined task (task no. "+string(i)+")");
        }
        if (typeof(tasks[#[i].index]) != "internal_task") {
            ERROR("cannot start an undefined task (task no. "+string(i)+")");
        }
        if (tasks[#[i].index].state != "created"
            && tasks[#[i].index].state != "stopped") {
            ERROR("cannot start a task whose state is not"+newline
                +"'created' or 'stopped'");
        }
    }
    for (i = nargs; i > 0; i--) {
        tasks[#[i].index].id = i;
        tasks[#[i].index].state = "started";
    }
    int pid = system("pid");
    link l(pid) = "ssi:fork";
    open(l(pid));
    write(l(pid), quote(startTasks_child(#, pid)));
    int port = read(l(pid));
    link L(pid) = "ssi:connect localhost:"+string(port);
    open(L(pid));
    for (i = nargs; i > 0; i--) {
        tasks[#[i].index].id = i;
        tasks[#[i].index].state = "started";
    }
    for (i = nargs; i > 0; i--) {
        tasks[#[i].index].links = list(L(pid), l(pid));
    }
}
example
{
    "EXAMPLE:";
    echo = 2;
    ring r = 0, (x,y), dp;
    ideal i = x, x+y;
    list L = startTasks(list("std", "slimgb"), list(list(i), list(i)));
    read(L[1]);
    read(L[1]);
    read(L[1]);
    read(L[1]);
}

/* This procedure is started within the child after forking. */
static proc startTasks_child(list localtasks, int pid_parent)
{
    int port = system("reserve", 1);
    write(l(pid_parent), port);
    link L(pid_parent) = system("reservedLink");
    export(L(pid_parent));

    int sem_write = semaphore(1);
    int pid = system("pid");

    int nlocaltasks = size(localtasks);
    intvec state = 0:nlocaltasks;
    int nwaiting = nlocaltasks;
    int nfinished;
    intvec queue = 0, 1..nlocaltasks, 0;   // zeroes for easier handling

    list links;
    links[nlocaltasks+1] = l(pid_parent);
    intvec assignment = 0:nlocaltasks;
    int nlinks;

    int granted_leaves;

    int wait;
    int id;
    int code;
    int waited_for;
    int tmp;

    while (nwaiting > 0) {
        wait = 0;
        if (nlinks == 0) {
            wait = -1;
            granted_leaves++;
            while (-wait < nwaiting) {
                if (system("semaphore", "try_acquire", sem_leaves) == 1) {
                    wait--;
                }
                else {
                    break;
                }
            }
        }
        while (wait == 0) {
            wait = waitfirst(links, 1000);
            // wait == -1 (all links crashed) should not happen
            if (wait == 0) {
                while (-wait < nwaiting) {
                    if (system("semaphore", "try_acquire", sem_leaves) == 1) {
                        wait--;
                    }
                    else {
                        break;
                    }
                }
            }
        }
        if (wait < 0) {   // open (-wait) new links
            while (wait < 0) {
                wait++;
                nlinks++;
                link ll(pid)(nlinks) = "ssi:fork";
                open(ll(pid)(nlinks));
                links[nlinks] = ll(pid)(nlinks);
                write(links[nlinks],
                    quote(startTasks_grandchild(
                    eval(localtasks[queue[2]].index), eval(pid_parent),
                    eval(pid), eval(nlinks), eval(sem_write))));
                assignment[queue[2]] = nlinks;
                state[queue[2]] = 1;
                nwaiting--;
                queue = 0, queue[3..size(queue)];
            }
            // wait == 0
        }
        if (wait > 0 && wait <= nlocaltasks) {
            id = read(links[wait]);
            code = read(links[wait]);
            if (code == 1) {   // result computed
                state[id] = 2;
                if (id == waited_for) {
                    write(links[wait], 1);
                    waited_for = 0;
                }
            }
            if (code == 2) {   // result sent
                read(links[wait]);
                write(links[wait],
                    quote(startTasks_grandchild(
                    eval(localtasks[queue[2]].index), eval(pid_parent),
                    eval(pid), eval(wait), eval(sem_write))));
                assignment[queue[2]] = wait;
                assignment[id] = 0;
                state[queue[2]] = 1;
                state[id] = 3;
                nwaiting--;
                nfinished++;
                queue = 0, queue[3..size(queue)];
            }
        }
        if (wait == nlocaltasks+1) {
            id = read(l(pid_parent));
            code = read(l(pid_parent));
            if (code == 0) {   // stop
                if (state[id] == 0) {   // waiting
                    queue = removeFromQueue(queue, id);
                }
                if (state[id] == 1 || state[id] == 2) {  // started or computed
                    close(links[assignment[id]]);
                    open(links[assignment[id]]);
                    write(links[assignment[id]],
                        quote(startTasks_grandchild(
                        eval(localtasks[queue[2]].index), eval(pid_parent),
                        eval(pid), eval(assignment[id]), eval(sem_write))));
                    assignment[queue[2]] = assignment[id];
                    assignment[id] = 0;
                    state[queue[2]] = 1;
                    queue = 0, queue[3..size(queue)];
                }
                // state[id] == -1 (stopped) or state[id] == 3 (sent)
                // should not happen
                nwaiting--;
                nfinished++;
                write(l(pid_parent), state[id]);
                state[id] = -1;
            }
            if (code == 1) {   // wait
                if (state[id] == 0) {   // waiting
                    granted_leaves++;
                    nlinks++;
                    link ll(pid)(nlinks) = "ssi:fork";
                    open(ll(pid)(nlinks));
                    links[nlinks] = ll(pid)(nlinks);
                    write(links[nlinks],
                        quote(startTasks_grandchild(
                        eval(localtasks[id].index), eval(pid_parent),
                        eval(pid), eval(nlinks), eval(sem_write))));
                    assignment[id] = nlinks;
                    state[id] = 1;
                    nwaiting--;
                    queue = removeFromQueue(queue, id);
                    waited_for == id;
                }
                if (state[id] == 1) {   // started
                    waited_for = id;
                }
                if (state[id] == 2) {   // computed
                    write(links[assignment[id]], 1);
                }
                write(l(pid_parent), state[id]);
            }
            if (code == 2) {   // poll
                if (state[id] == 2) {   // computed
                    write(links[assignment[id]], 1);
                }
                write(l(pid_parent), state[id]);
            }
        }
    }
    while (nfinished < nlocaltasks) {
        wait = waitfirst(links);
        if (wait <= nlocaltasks) {
            id = read(links[wait]);
            code = read(links[wait]);
            if (code == 1) {   // result computed
                state[id] = 2;
                if (id == waited_for) {
                    write(links[wait], 1);
                    waited_for = 0;
                }
            }
            if (code == 2) {   // result sent
                read(links[wait]);
                close(links[wait]);
                if (nlinks > granted_leaves) {
                    tmp = system("semaphore", "release", sem_leaves);
                }
                links[wait] = def(0);
                nlinks--;
                assignment[id] = 0;
                state[id] = 3;
                nfinished++;
            }
        }
        if (wait == nlocaltasks+1) {
            id = read(l(pid_parent));
            code = read(l(pid_parent));
            if (code == 0) {   // stop
                if (state[id] == 1 || state[id] == 2) {  // started or computed
                    close(links[assignment[id]]);
                    if (nlinks > granted_leaves) {
                        tmp = system("semaphore", "release", sem_leaves);
                    }
                    links[assignment[id]] = def(0);
                    nlinks--;
                    assignment[id] = 0;
                    nfinished++;
                }
                // else: nothing to do
                write(l(pid_parent), state[id]);
                state[id] = -1;
            }
            if (code == 1) {   // wait
                if (state[id] == 1) {   // started
                    waited_for = id;
                }
                if (state[id] == 2) {   // computed
                    write(links[assignment[id]], 1);
                }
                write(l(pid_parent), state[id]);
            }
            if (code == 2) {   // poll
                if (state[id] == 2) {   // computed
                    write(links[assignment[id]], 1);
                }
                write(l(pid_parent), state[id]);
            }
        }
    }
    exit;
}

/* This procedure has to be started within the grandchildren after forking. */
static proc startTasks_grandchild(int index, int pid_grandparent,
    int pid_parent, int link_no, int sem_write)
{
    def result;
    int tmp = system("semaphore", "acquire", sem_queue);
    tmp = system("semaphore", "acquire", sem_cores);
    tmp = system("semaphore", "release", sem_queue);
    execute("result = "+tasks[index].command+"("
        +argsToString("tasks[index].arguments", size(tasks[index].arguments))
        +");");
    tmp = system("semaphore", "release", sem_cores);
    write(ll(pid_parent)(link_no), tasks[index].id);
    write(ll(pid_parent)(link_no), 1);
    tmp = read(ll(pid_parent)(link_no));
    tmp = system("semaphore", "acquire", sem_write);
    write(L(pid_grandparent), index);
    write(L(pid_grandparent), result);
    tmp = system("semaphore", "release", sem_write);
    write(ll(pid_parent)(link_no), tasks[index].id);
    write(ll(pid_parent)(link_no), 2);
}

static proc removeFromQueue(intvec queue, int id)
{
    int size_queue = size(queue);
    int i;
    for (i = size_queue-1; i > 1; i--) {
        if (queue[i] == id) {
            return(queue[1..(i-1)], queue[(i+1)..size_queue]);
        }
    }
    return(queue);
}

proc stopTask(task t)
"USAGE:   stopTask(l); l link
RETURN:   none. Stops the task as soon as possible.
SEE ALSO: startTask, waitTask, pollTask, parallel_lib
KEYWORDS: Parallelization; Links
EXAMPLE:  example stopTask; shows an example"
{
    if (t.index == 0) {
        ERROR("cannot stop an undefined task");
    }
    if (typeof(tasks[t.index]) != "internal_task") {
        ERROR("cannot stop an undefined task");
    }
    if (tasks[t.index].state != "started") {
        ERROR("cannot stop a task whose state is not 'started'");
    }
    write(tasks[t.index].links[2], tasks[t.index].id);
    write(tasks[t.index].links[2], 0);
    int state = read(tasks[t.index].links[2]);
    tasks[t.index].id = 0;
    tasks[t.index].links = list();
    tasks[t.index].state = "stopped";
}
example
{
    "EXAMPLE:";
    echo = 2;
    ring r = 0, (x,y,z), lp;
    ideal i = 3x3y+x3+xy3+y2z2, 2x3z-xy-xz3-y4-z2, 2x2yz-2xy2+xz2-y4;
    link l = startTask("std", list(i));
    system("sh", "sleep 3s");
    stopTask(l);
}

proc waitTask(task t)
"USAGE:   waitTask(l); l link
RETURN:   the result of the task. This command is eventually blocking.
SEE ALSO: startTask, stopTask, pollTask, parallel_lib
KEYWORDS: Parallelization; Links
EXAMPLE:  example waitTask; shows an example"
{
    if (t.index == 0) {
        ERROR("cannot wait for an undefined task");
    }
    if (typeof(tasks[t.index]) != "internal_task") {
        ERROR("cannot wait for an undefined task");
    }
    if (tasks[t.index].state != "started"
        && tasks[t.index].state != "completed") {
        ERROR("cannot wait for a task whose state is not"+newline
            +"'started' or 'completed'");
    }
    if (tasks[t.index].state == "completed") {
        return();
    }
    // tasks[t.index].state == "started"
    write(tasks[t.index].links[2], tasks[t.index].id);
    write(tasks[t.index].links[2], 1);
    int state = read(tasks[t.index].links[2]);
    if (state == 0 || state == 1) {   // waiting or started
        int tmp = system("semaphore", "release", sem_cores);
        tmp = waitfirst(tasks[t.index].links);
        tmp = system("semaphore", "acquire", sem_cores);
    }
    // else (and now in any case): state == 2 (computed).
    // state == -1 (stopped) of state == 3 (sent) should not happen
    int index = read(tasks[t.index].links[1]);
    tasks[t.index].result = read(tasks[t.index].links[1]);
    tasks[t.index].id = 0;
    tasks[t.index].links = list();
    tasks[t.index].state = "completed";
}
example
{
    "EXAMPLE:";
    echo = 2;
    ring r = 0, (x,y), dp;
    ideal i = x, x+y;
    link l = startTask("std", list(i));
    waitTask(l);
}

proc pollTask(task t)
"USAGE:   pollTask(l); l link
RETURN:   a list result. result[1] is 1 if the task is finished and 0
          otherwise. If the task is finished, then result[2] is the
          result of the task.
SEE ALSO: startTask, stopTask, waitTask, parallel_lib
KEYWORDS: Parallelization; Links
EXAMPLE:  example pollTask; shows an example"
{
    if (t.index == 0) {
        ERROR("cannot poll an undefined task");
    }
    if (typeof(tasks[t.index]) != "internal_task") {
        ERROR("cannot poll an undefined task");
    }
    if (tasks[t.index].state != "started"
        && tasks[t.index].state != "completed") {
        ERROR("cannot poll a task whose state is not"+newline
            +"'started' or 'completed'");
    }
    if (tasks[t.index].state == "completed") {
        return(1);
    }
    // tasks[t.index].state == "started"
    write(tasks[t.index].links[2], tasks[t.index].id);
    write(tasks[t.index].links[2], 2);
    int state = read(tasks[t.index].links[2]);
    if (state == 0 || state == 1) {   // waiting or started
        return(0);
    }
    if (state == 2) {   // computed
        int index = read(tasks[t.index].links[1]);
        tasks[t.index].result = read(tasks[t.index].links[1]);
        tasks[t.index].id = 0;
        tasks[t.index].links = list();
        tasks[t.index].state = "completed";
        return(1);
    }
    // state == -1 (stopped) or state == 3 (sent) should not happen
}
example
{
    "EXAMPLE:";
    echo = 2;
    ring r = 0, (x,y,z), lp;
    ideal i = 3x3y+x3+xy3+y2z2, 2x3z-xy-xz3-y4-z2, 2x2yz-2xy2+xz2-y4;
    link l1 = startTask("std", list(i));
    system("sh", "sleep 3s");
    // the task is not yet finished
    pollTask(l1);
    stopTask(l1);
    ring s = 0, (x,y), dp;
    ideal i = x, x+y;
    link l2 = startTask("std", list(i));
    system("sh", "sleep 1s");
    // the task is finished
    pollTask(l2);
}

proc getResult(task t)
{
    if (t.index == 0) {
        ERROR("cannot get result of an undefined task");
    }
    if (typeof(tasks[t.index]) != "internal_task") {
        ERROR("cannot get result of an undefined task");
    }
    if (tasks[t.index].state != "completed") {
        ERROR("cannot get result of a task which is not completed");
    }
    return(tasks[t.index].result);
}

proc getState(task t)
{
    if (t.index == 0) {
        return("undefined");
    }
    if (typeof(tasks[t.index]) != "internal_task") {
        return("undefined");
    }
    return(tasks[t.index].state);
}

proc semaphore(int n)
{
    int i = 1;
    while (system("semaphore", "exists", i) == 1) {
        i++;
    }
    if (system("semaphore", "init", i, n) != 1) {
        ERROR("no more semphores");
    }
    return(i);
}

/ * construct the string "name[1], name[2], name[3], ..., name[length]" */
static proc argsToString(string name, int length)
{
    string output;
    if (length > 0) {
        output = name+"[1]";
    }
    int i;
    for (i = 2; i <= length; i++) {
        output = output+", "+name+"["+string(i)+"]";
    }
    return(output);
}

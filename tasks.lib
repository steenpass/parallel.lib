////////////////////////////////////////////////////////////////////
version="$Id$";
category="General purpose";
info="
LIBRARY:   semaphore.lib  An interface for tasks using semaphores
AUTHOR:    Andreas Steenpass, e-mail: steenpass@mathematik.uni-kl.de

SEE ALSO:  link, parallel_lib, resources_lib

KEYWORDS:  Semaphores; Parallelization; Links, user interface

PROCEDURES:
  startTask(string, list)   start a new task
  stopTask(link)            stop the task
  waitTask(link)            wait for the task and pick up the result
  pollTask(link)            pick up the result, if task is ready;
                            return immediately, otherwise
";

LIB "resources.lib";

static proc mod_init()
{
    int tmp = system("semaphore", "init", 1, system("cpu")+2);
    tmp = system("semaphore", "init", 2, 2);
}

proc startTask(string command, list arguments, list #)
"USAGE:   startTask(command, arguments[, linktype]); command string,
          arguments list, linktype string
RETURN:   a link l, running the computation which applies command to arguments
          as soon as there are free resources.
          @* An optional linktype can be provided as a string. Currently
          supported linktypes are \"ssi\" (default, see @ref{Ssi links}) and
          \"mp\" (see @ref{MP links}).
          MP links do not work with a 64 bit version of Singular. If you want
          to use MP links, make sure that MP is available. This can be checked
          by the Singular command @code{system(\"with\", \"MP\");}.
SEE ALSO: startNTasks, stopTask, waitTask, pollTask, parallel_lib, Ssi links,
          MP links
KEYWORDS: Parallelization; Links
EXAMPLE:  example startTask; shows an example"
{
    /* read optional parameter */
    string linktype = "ssi";
    if (size(#) > 0) {
        if (size(#) > 1 || typeof(#[1]) != "string") {
            ERROR("wrong optional parameter");
        }
        linktype = #[1];
    }

    /* check for errors */
    if (linktype != "ssi" && linktype != "mp") {
        ERROR("invalid linktype");
    }
    if (linktype == "mp" && !system("with", "MP")) {
        ERROR("MP is not available");
    }

    /* start the task */
    if (linktype == "ssi") {
        link l = "ssi:fork";
    }
    else {   // linktype == "mp"
        link l = "MPtcp:fork";
    }
    open(l);
    write(l, quote(startTask_child(command, arguments)));

    /* return link */
    return(l);
}
example
{
    "EXAMPLE:";
    echo = 2;
    ring r = 0, (x,y), dp;
    ideal i = x, x+y;
    link l = startTask("std", list(i));
    waitTask(l);
}

/* This procedure has to be started within the child after forking. */
static proc startTask_child(string command, list arguments)
{
    def result;
    int tmp = system("semaphore", "acquire", 0);
    execute("result = "+command+"("+argsToString("arguments", size(arguments))
        +");");
    export(result);
    tmp = system("semaphore", "release", 0);
}

proc startNTasks(list commands, list Arguments)
"USAGE:   startNTasks(commands, Arguments); commands list, Arguments list
RETURN:   a list L of two links. L[2] gives access to a supervisor link
          (*not* in the sense of scheduling) which usually remains
          unused, but shouldn't be closed or killed before enough
          results are obtained. The results can be read off from L[1].
          One result is read by applying the command read(L[1]) twice: The
          first call gives the index (of the command and its arguments
          within the input lists), the second call gives the actual
          result. The next call of read(L[1]) then gives the next index
          and so on.
SEE ALSO: startTask, stopTask, waitTask, pollTask, parallel_lib, Ssi links,
          MP links
KEYWORDS: Parallelization; Links
EXAMPLE:  example startNTasks; shows an example"
{
    /* check for errors */
    // TODO

    int pid = system("pid");
    link l(pid) = "ssi:fork";
    open(l(pid));
    write(l(pid), quote(startNTasks_child(commands, Arguments, pid)));
    int p = read(l(pid));
    link L(pid) = "ssi:connect localhost:"+string(p);
    open(L(pid));
    return(list(L(pid), l(pid)));
}
example
{
    "EXAMPLE:";
    echo = 2;
    ring r = 0, (x,y), dp;
    ideal i = x, x+y;
    list L = startNTasks(list("std", "slimgb"), list(list(i), list(i)));
    read(L[1]);
    read(L[1]);
    read(L[1]);
    read(L[1]);
}

/* This procedure has to be started within the child after forking. */
static proc startNTasks_child(list commands, list Arguments, int pid_parent)
{
    int p = system("reserve", 1);
    write(l(pid_parent), p);
    link L(pid_parent) = system("reservedLink");
    export(L(pid_parent));

    int sem = semaphore(1);

    int ncommands = size(commands);
    int pid = system("pid");
    list links;
    links[ncommands+1] = l(pid_parent);
    int nlinks;
    int nsubmitted;
    int do_close;
    int wait;
    int tmp;
    while (nsubmitted < ncommands && !do_close) {
        wait = 0;
        if (nlinks == 0) {
            nlinks++;
            link ll(pid)(nlinks) = "ssi:fork";
            open(ll(pid)(nlinks));
            links[nlinks] = ll(pid)(nlinks);
            wait = nlinks;
        }
        while (wait == 0) {
            wait = waitfirst(links, 1000);
            if (wait > 0 && wait <= ncommands) {
                tmp = read(links[wait]);
            }
            if (wait == 0) {
                if (system("semaphore", "try_acquire", 1) == 1) {
                    nlinks++;
                    link ll(pid)(nlinks) = "ssi:fork";
                    open(ll(pid)(nlinks));
                    links[nlinks] = ll(pid)(nlinks);
                    wait = nlinks;
                }
            }
            if (wait == ncommands+1) {
                tmp = read(l(pid_parent));
                do_close = 1;
                break;
            }
        }
        if (!do_close) {
            nsubmitted++;
            write(links[wait],
                quote(startNTasks_grandchild(commands[eval(nsubmitted)],
                Arguments[eval(nsubmitted)], eval(nsubmitted), eval(sem),
                eval(pid_parent))));
        }
    }
    while (!do_close) {
        wait = waitfirst(links);
        tmp = read(links[wait]);
        if (wait <= ncommands) {
            close(links[wait]);
            if (nlinks > 1) {
                tmp = system("semaphore", "release", 1);
            }
            links[wait] = def(0);
            nlinks--;
        }
        if (wait == ncommands+1) {
            do_close = 1;
        }
    }
    while (nlinks > 0) {
        wait = waitfirst(links, 0);
        if (wait > 0) {
            tmp = read(links[wait]);
        }
        if (wait == 0) {
            wait = 1;
            while(typeof(links[wait]) != "link") {
                wait++;
            }
        }
        if (wait <= ncommands) {
            close(links[wait]);
            if (nlinks > 1) {
                tmp = system("semaphore", "release", 1);
            }
            links[wait] = def(0);
            nlinks--;
        }
    }
    write(l(pid_parent), 1);
}

/* This procedure has to be started within the grandchildren after forking. */
static proc startNTasks_grandchild(string command, list arguments, int i,
    int sem, int pid_grandparent)
{
    def result;
    int tmp = system("semaphore", "acquire", 2);
    tmp = system("semaphore", "acquire", 0);
    tmp = system("semaphore", "release", 2);
    execute("result = "+command+"("+argsToString("arguments", size(arguments))
        +");");
    tmp = system("semaphore", "release", 0);
    tmp = system("semaphore", "acquire", sem);
    write(L(pid_grandparent), i);
    write(L(pid_grandparent), result);
    tmp = system("semaphore", "release", sem);
    return(i);
}

proc stopTask(link l)
"USAGE:   stopTask(l); l link
RETURN:   none. Stops the task as soon as possible.
SEE ALSO: startTask, waitTask, pollTask, parallel_lib
KEYWORDS: Parallelization; Links
EXAMPLE:  example stopTask; shows an example"
{
    int not_ready;
    if (!status(l, "read", "ready")) {
        not_ready = 1;
    }
    close(l);
    if (not_ready) {
        // At the following line, race conditions might occur.
        int tmp = system("semaphore", "release", 0);
    }
}
example
{
    "EXAMPLE:";
    echo = 2;
    ring r = 0, (x,y,z), lp;
    ideal i = 3x3y+x3+xy3+y2z2, 2x3z-xy-xz3-y4-z2, 2x2yz-2xy2+xz2-y4;
    link l = startTask("std", list(i));
    system("sh", "sleep 3s");
    stopTask(l);
}

proc waitTask(link l)
"USAGE:   waitTask(l); l link
RETURN:   the result of the task. This command is eventually blocking.
SEE ALSO: startTask, stopTask, pollTask, parallel_lib
KEYWORDS: Parallelization; Links
EXAMPLE:  example waitTask; shows an example"
{
    int not_ready;
    int tmp;
    if (!status(l, "read", "ready")) {
        tmp = system("semaphore", "release", 0);
        not_ready = 1;
    }
    read(l);
    if (not_ready) {
        tmp = system("semaphore", "acquire", 0);
    }
    write(l, quote(result));
    def result = read(l);
    close(l);
    return(result);
}
example
{
    "EXAMPLE:";
    echo = 2;
    ring r = 0, (x,y), dp;
    ideal i = x, x+y;
    link l = startTask("std", list(i));
    waitTask(l);
}

proc pollTask(link l)
"USAGE:   pollTask(l); l link
RETURN:   a list result. result[1] is 1 if the task is finished and 0
          otherwise. If the task is finished, then result[2] is the
          result of the task.
SEE ALSO: startTask, stopTask, waitTask, parallel_lib
KEYWORDS: Parallelization; Links
EXAMPLE:  example pollTask; shows an example"
{
    list result;
    if (status(l, "read", "ready")) {
        result[1] = 1;
        result[2] = waitTask(l);
    }
    else {
        result[1] = 0;
    }
    return(result);
}
example
{
    "EXAMPLE:";
    echo = 2;
    ring r = 0, (x,y,z), lp;
    ideal i = 3x3y+x3+xy3+y2z2, 2x3z-xy-xz3-y4-z2, 2x2yz-2xy2+xz2-y4;
    link l1 = startTask("std", list(i));
    system("sh", "sleep 3s");
    // the task is not yet finished
    pollTask(l1);
    stopTask(l1);
    ring s = 0, (x,y), dp;
    ideal i = x, x+y;
    link l2 = startTask("std", list(i));
    system("sh", "sleep 1s");
    // the task is finished
    pollTask(l2);
}

/ * construct the string "name[1], name[2], name[3], ..., name[length]" */
proc argsToString(string name, int length)
{
    string arglist;
    if (length > 0) {
        arglist = name+"[1]";
    }
    int i;
    for (i = 2; i <= length; i++) {
        arglist = arglist+", "+name+"["+string(i)+"]";
    }
    return(arglist);
}

proc semaphore(int n)
{
    int i = 1;
    while (system("semaphore", "exists", i) == 1) {
        i++;
    }
    if (system("semaphore", "init", i, n) != 1) {
        ERROR("no more semphores");
    }
    return(i);
}
